<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Quality Tracker Dashboard</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f8f8f8;
        margin: 20px;
        color: #333;
      }
      h1 {
        text-align: center;
      }
      #dashboardTable {
        width: 100%;
        border-collapse: collapse;
        margin-top: 20px;
      }
      th, td {
        padding: 8px 12px;
        border: 1px solid #ddd;
        text-align: left;
      }
      th {
        background: #007acc;
        color: #fff;
      }
      tr:nth-child(even) {
        background: #f0f0f0;
      }
      .loading {
        text-align: center;
        margin-top: 40px;
        font-size: 1.2em;
      }
    </style>
  </head>
  <body>
    <h1>Quality Tracker Dashboard</h1>
    <div id="loading" class="loading">Loading dashboard data...</div>
    <table id="dashboardTable" style="display: none;">
      <thead>
        <tr>
          <th>Check Location Pair</th>
          <th>DeviationEndDate</th>
          <th>Notifications</th>
          <th>Total Previous Warnings</th>
          <th>Total Previous Deviations</th>
        </tr>
      </thead>
      <tbody>
        <!-- Dashboard rows inserted here -->
      </tbody>
    </table>

    <script>
      // Fetch data.json served by GitHub Pages.
      fetch("data.json")
        .then(response => {
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          return response.json();
        })
        .then(data => {
          document.getElementById("loading").style.display = "none";
          document.getElementById("dashboardTable").style.display = "table";

          // Group rows by "Check Location Pairs"
          const groups = {};
          data.forEach(row => {
            const clp = row["Check Location Pairs"];
            if (!groups[clp]) {
              groups[clp] = [];
            }
            groups[clp].push(row);
          });

          const tbody = document.querySelector("#dashboardTable tbody");

          // Process each group
          Object.keys(groups).forEach(groupKey => {
            let groupRows = groups[groupKey];

            // Sort rows in ascending order by Date (assumes mm/dd/yyyy or ISO-like format)
            groupRows.sort((a, b) => new Date(a["Date"]) - new Date(b["Date"]));

            // Determine the last warning row index.
            // A row is considered a warning if its Warning# value is non-empty.
            let lastWarningIndex = -1;
            groupRows.forEach((r, idx) => {
              if (r["Warning#"] && r["Warning#"].toString().trim() !== "") {
                lastWarningIndex = idx;
              }
            });

            // Define the "current cycle" as all rows after (i.e., with higher index than) lastWarningIndex.
            let currentCycle = [];
            if (lastWarningIndex >= 0) {
              currentCycle = groupRows.slice(lastWarningIndex + 1);
            } else {
              // If no warning exists at all, current cycle is all rows.
              currentCycle = groupRows;
            }
            if (currentCycle.length === 0) {
              // If there are no notifications after the last warning, skip this group.
              return;
            }

            // The latest notification is the one with the maximum Date among currentCycle.
            let latestRow = currentCycle.reduce((latest, curr) => {
              return new Date(curr["Date"]) > new Date(latest["Date"]) ? curr : latest;
            }, currentCycle[0]);

            // "Notifications": use the Offense# value from the latest notification row.
            let notifications = latestRow["Offense#"];

            // "Total Previous Warnings": count the warnings (non-empty Warning#) from all rows
            // that occurred BEFORE the current cycle (i.e. in groupRows[0...lastWarningIndex])
            let totalPrevWarnings = lastWarningIndex >= 0 ? groupRows.slice(0, lastWarningIndex + 1)
              .filter(r => r["Warning#"] && r["Warning#"].toString().trim() !== "").length
              : 0;

            // "Total Previous Deviations": count the warnings whose Warning# starts with "Dev"
            // from the rows before the current cycle.
            let totalPrevDeviations = lastWarningIndex >= 0 ? groupRows.slice(0, lastWarningIndex + 1)
              .filter(r => r["Warning#"] && r["Warning#"].toString().startsWith("Dev")).length
              : 0;

            // "DeviationEndDate": if the latest notification's Warning# starts with "Dev",
            // display its DeviationEndDate along with days remaining in brackets.
            let deviationEndDisplay = "";
            if (latestRow["Warning#"] && latestRow["Warning#"].toString().startsWith("Dev")) {
              let endDate = latestRow["DeviationEndDate"];
              let daysRemaining = latestRow["DaysToDeviationEndDate"];
              deviationEndDisplay = `${endDate} (${daysRemaining})`;
            }

            // Build a row for the dashboard.
            const tr = document.createElement("tr");
            tr.innerHTML = `
              <td>${groupKey}</td>
              <td>${deviationEndDisplay}</td>
              <td>${notifications}</td>
              <td>${totalPrevWarnings}</td>
              <td>${totalPrevDeviations}</td>
            `;
            tbody.appendChild(tr);
          });
        })
        .catch(error => {
          console.error("Error fetching data.json:", error);
          document.getElementById("loading").innerText = "Failed to load dashboard data.";
        });
    </script>
  </body>
</html>
